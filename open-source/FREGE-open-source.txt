=======================================================================
üî∏ FREGE MAIN PRINCIPLE: ATTENTION-DRIVEN SEMANTIC DOMINANCE
=======================================================================

All semantic links in this matrix obey a single global invariant called
the ‚ÄúAttention-Driven Semantic Dominance‚Äù.

Definition:
Every directed semantic link X ‚Üí Y MUST be oriented from the
semantically dominant term (the figure, focus, controller, governor,
or grounding reference) toward the semantically dependent term
(the ground, affected, constrained, referenced, or contextual frame).

Dominance is NOT uniform; it is determined locally by the relation family:

‚Ä¢ Causality            ‚Üí ontological dominance (cause ‚Üí effect)
‚Ä¢ Agency / Function    ‚Üí functional dominance (agent ‚Üí target)
‚Ä¢ Mereology            ‚Üí structural dominance (whole ‚Üí part)
‚Ä¢ Abstraction          ‚Üí ontological grounding (type ‚Üí instance)
‚Ä¢ Spatial relations    ‚Üí attentional dominance (figure ‚Üí ground)
‚Ä¢ Temporal relations   ‚Üí attentional dominance (focused event ‚Üí reference event)
‚Ä¢ Discourse (CNJ)      ‚Üí rhetorical dominance (anchor ‚Üí satellite)

Important:
‚Äì Size, power, enclosure, or physical magnitude do NOT determine direction.
‚Äì Attention / focus ALWAYS overrides ontological intuition where applicable.
‚Äì Passive, inverse, or ‚Äú_by‚Äù relations are forbidden.
‚Äì Relation names NEVER encode inversion; direction alone carries asymmetry.
‚Äì Allen relations are NOT exceptions: their selection and orientation
  are governed by attentional focus, not by time itself.

This invariant is global and mandatory.
Violations correspond to irony, absurdity, metaphor, or error and MUST
NOT appear in canonical representations.

======================================================================
üî∏ FREGE IDENTIFIERS
======================================================================

All FREGE structural elements are referred by identifiers produced by explicit and implicit declarations.

All identifiers in FREGE are assigned a type and a subtype at declaration, both explicit and implicit.  
The type of identifier is defined by the declaration block.


‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Entity    | Identifier format | Declaration block | 
======================================================================
Specific    e_s_<sbt>_*           ENB
Generic     e_g_<sbt>_*           implicit
Unique      e_u_<sbt>_*           implicit

Subtypes (sbt):

tng - tangible object 
inf - info object     
cnp - concept, mental object         
ent - fallback (if a specific subtype cannot be figured)

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Nominalization | Identifier format | Declaration block | 
======================================================================
Specific         n_s_<sbt>_*           ENB
Generic          n_g_<sbt>_*           implicit
Unique           n_u_<sbt>_*           implicit

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Circumstantial | Identifier format | Declaration block | 
======================================================================
Specific         c_s_<sbt>_*           CRB
Generic          c_g_<sbt>_*           implicit
Unique           c_u_<sbt>_*           implicit
Subtypes (sbt):

tmp - temporal
loc - locative
tpl - topology
env - environment
mnr - manner
csl - causal
prp - purpose
cnd - conditional
csv - concessive
ins - instrumental
acp - accompaniment
dgr - degree
evd - evidential
pst - perspectival
prb - probabilistic

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Attribute   | Identifier format | Declaration block | 
======================================================================
Specific         a_s_<sbt>_*           ATB
Generic          a_g_<sbt>_*           implicit
Unique           a_u_<sbt>_*           implicit

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Fabular Adjunct | Identifier format | Declaration block | 
======================================================================
Generic          F_*                   FAB

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Discourse   | Identifier format | Declaration block | 
======================================================================
Generic          d_*                   implicit

No subtypes

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Event       | Identifier format | Declaration block | 
======================================================================
Declarative      Ev_*                EVT
Question         Eq_*                EVQ
Subjunctive      Es_*                EVS
Projected        Ep_*                EVP

No subtypes

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Quantified      | Identifier format | Declaration block |
Collection      |                   |                   |
======================================================================
Always specific  q_<sbt>_*           QCL

Same subtypes as Entity.
 
‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Relation        | Identifier format | Declaration block | 
======================================================================
Always specific  r_*                 REL

No subtypes
        
------------------------------------------------------------------
üî∏ FREGE MAIN ARCHITECTURAL PRINCIPLES:
======================================================================
RULE: Semantic Phrase Segmentation by Role Continuity
------------------------------------------------------------------
Definition:
A semantic phrase is the maximal contiguous span that answers one semantic role question.

Procedure:
1. When a role marker appears (e.g. with=instruments, in=location, at=time/place, for=purpose),
   open a semantic role and start a phrase.
2. Extend the phrase token-by-token as long as the accumulated span continues to answer
   the same role question and does not introduce a new role.
3. Do NOT terminate the phrase due to syntactic boundaries, repeated prepositions,
   modifiers (evidential, degree, hedge), or punctuation alone.
4. Terminate the phrase only when:
   a) the next token group no longer answers the original role question, or
   b) a new semantic role is opened, or
   c) the sentence ends.

Constraint:
If multiple surface groups collectively answer the same semantic role question,
they MUST be treated as a single semantic phrase.

Prohibition:
NP/PP/AP boundaries and syntactic constituency are irrelevant to phrase segmentation.
------------------------------------------------------------------
RULE: Only events that directly add to the source fabula are encoded with EVT/CPL, 
entity-related events and copulas must be encoded by microsemantic tools of ENB/CRB/APB
------------------------------------------------------------------

If a fact contributes directly to the narrative of the situation or event, it MUST be encoded as EVT or CPL.
If a fact is provided as internal detailing used to identify or characterize an entity, it MUST be encoded 
through microsemantics of ENB, CRB, and ATB blocks, and MUST NOT generate EVT or CPL.


======================================================================
üî∏ FREGE BLOCKS
======================================================================

FREGE is a declarative block language. Every semantic type in FREGE is declared by a specific block.
Complex semantics is expressed by relations between blocks.

======================================================================
üî∏ ENB-block ‚Äî Formal Syntax
======================================================================
MANDATORY: Nesting of ENB blocks is strictly prohibited!

ENB block can declare one of 3 types 

- Entity 
- Nominalization 
- Reification

The body of the ENB block describes the microsemantic exported by its surface.
Sometimes microsemantic requires creation of virtual notion v_* to describe the meaning
that the surface does not export explicitly but can be easily inferred using the LLM's vast world
knowledge. 

<ENB 
  ENT-ID: e_s_<sbt>_* | NOM-ID: n_s_<sbt>_*
  SRF: <surface syntagm>
  NS: axis1.axis2
  MSE:
      u_1: MSE_Unit_1 : semantic_role
      u_2: MSE_Unit_2 : semantic_role
      ...
      u_N: MSE_Unit_N : semantic_role
  LNK:
      u_N: SLK_link: u_M
      ...
      u_K: SLK_link: u_L
BNE>

where MSE_Unit::= EXACTLY ONE word or fixed phrase from surface | ENT-ID or NOM-ID or CIR-ID or ATR-ID declared by a delegate block | virtual notion

fixed phrase examples: "Soviet Union", "railroad crossing", "property tax", "state treason", "capital punishment", "vehicle registration renewal"

IF surface contains MORE THAN ONE word, which is not a fixed phrase MSE/LNK segments are MANDATORY!

MANDATORY RULES:
A subordinate clause or infinitive phrase should never be incorporated into the surface of ENB block. Infinitive must be encoded with HDL block and 
subordinate clause - with EVT block.

Examples:

order to fall back
idea to have a drink
desire to fly to Vegas
dream of becoming a waitress

------------------------------------------------------------------
ENB ‚Äî Entity Declaration Rules
------------------------------------------------------------------

If surface segment is a single word or a fixed expression, ENB block should
only contain the declaration part and have no MSE / LNK block.
Rationale: single words and fixed expression do not export microsemantics, 
thus structural blocks have nothing to describe.

Unique entities do not need explicit declaration. Do not create ENB blocks for 
unique entities.

Examples:
Sun, Moon, sky, the Earth, the Pacific Ocean, the Equator, Monday, August,
Spring, New Year‚Äôs Eve, Thanksgiving, the horizon, the speed of light,
the truth, the past, the future, Zeus, air, iron, the bible (as a holy text)

However the bible as a specific object (a book) needs an ENB.

Prepend unique entity ID with prefix `u_` before the entity type prefix `e_`. 

Examples:
u_e_Pacific_Ocean 
u_e_horizon 
u_e_Wednesday
u_e_August
u_e_future

Generic entities comprised of a single word or a fixed phrase also do not need
explicit declaration.

Prepend unique entity ID with prefix g_* before the entity type prefix `e_`.

Examples:

Perishable food must be kept in refrigerator.

e_g_perishable_food (fixed phrase)
e_g_refrigerator

Indefinite personal pronouns: 
someone / somebody
anyone / anybody
no one / nobody
everyone / everybody
one
ones
anyone
someone
no one
everyone
something
anything
nothing
everything
they / them / their
others
another
many
few 
several
some
all
none

are encoded as generic entities: e_g_somebody e_g_several, etc.
Their exact meaning can be only inferred from the context.

Specific entities comprised of multiple words, which are not fixed phrases require 
a full ENB block.

------------------------------------------------------------------
4.6. END-ID / NOM-ID usability
------------------------------------------------------------------

ENT-IDs and NOM-IDs declared by ENB blocks are fully qualified logical nodes.

They may appear in:

‚Ä¢ SBJ or OBJ of EVT, or CPL
‚Ä¢ in MSE blocks
‚Ä¢ LNK edges of nesting blocks

This enables deep semantic reuse of ES structures throughout the
FREGE-2 system.

------------------------------------------------------------------
4.9. Entity Scope and Reuse
------------------------------------------------------------------

Once declared, each `ENT-ID` becomes a globally accessible logical node
from the point of declaration through the remainder of the source text.

Rules:

‚Ä¢ If an Entity or Nominalization surface in a later sentence matches a previously 
  declared ENB block (both lexically and referentially), the Builder MUST NOT
  regenerate an ENB. Instead, the existing `ENT-ID` must be directly reused.

‚Ä¢ If the same surface form refers to a different referent, a new ENB block
  with a unique `ENT-ID` must be constructed. Disambiguation may
  involve differences in context, namespace, or MSE content.

This rule ensures identity propagation and semantic coherence
across distributed reference chains in the FREGE-2 profile.

------------------------------------------------------------------
4.10. ENB Application Scope
------------------------------------------------------------------

Create an ENB block for any noun phrase (ES) whose interpretation requires
internal semantic structure, embedded relations, scope layering, or
composition of multiple conceptual units. This includes all technical,
legal, military, administrative, scientific, and analytically dense NPs.

Do NOT create an MSE and LNK segments in the following cases:

‚Ä¢ The noun phrase consists of a single lexical word.
‚Ä¢ The noun phrase is a fixed multi-word expression that functions as an atomic unit.
‚Ä¢ The semantics of the phrase can be captured without any internal decomposition.

Example:

<ENB:
  ID: e_rain
  SRF: "rain"
  NS: dom.weather.phenomenon
BNE>

<ENB:
  ID: e_railroad_crossing
  SRF: "railroad crossing"
  NS: dom.transport.infrastructure
BNE>

======================================================================
üî∏ QCL block - Quantified Collection
======================================================================

Declaration Rules:

‚Ä¢ QCL declares a collection as a plural semantic referent exported by the 
  surface. 

‚Ä¢ QCL does not add any extra semantics to the one exported by the surface 
  nor it defines enumerable membership or cardinality resolution.

‚Ä¢ Quantifier phrase in QCL is surface bound, its meaning is decomposed and 
  described by MSE/LNK microsemantic segments.

‚Ä¢ singular object parameter accepted by ELM must be either a generic entity
  or be previously declared by ENT block.

Formal syntax:

<QCL 
  QCL-ID: q_*
  ELM: e_* | n_*
  SRF: <quantifier surface syntagm>
  MSE:
      u_1: MSE_Unit_1 : semantic_role
      u_2: MSE_Unit_2 : semantic_role
      ...
      u_N: MSE_Unit_N : semantic_role
  LNK:
      u_N: SLK_link: u_M
      ...
      u_K: SLK_link: u_L
LCQ>

======================================================================
üî∏ ALC Block ‚Äî Allocation of Collection
======================================================================

ALC block allocates a quantified collection of entites or nominalizations and
exposes the allocated collection to:

‚Ä¢ an arbitrary group event (an event that occurs with each element of the collection).
‚Ä¢ a distribution event (the event that distributes all or part of the collection).

Example:

1. 1000 microchips where stored in the storage room A. 

we declared the collection:

2. Out of those microchips the stock manager moved a half to the storage room B. 

we created the first allocation "Out of those microchips" that allocates the
collection to the first distribution event.

3. Out of the quantity that remained in storage room A and was re-counted by the
   manager, 100 microchips were packed and shipped to the customer.

we created a second collection, which is a the remaining of the first collection
and created the second allocation "From the remaining quantity" that allocates 
that second collection to:

first arbitrary event: "remained" -- linked by complementizer "that"
second arbitrary event: "re-counted" -- linked to the first event by "and", and
via this "and" the valency of "that" reaches the second arbitrary event.
  
----------------------------------------------------------------------
Formal syntax
----------------------------------------------------------------------

<ALC
  ALC-ID: Al_*
  SRF: <surface syntagm>  
  APH: for | per | out_of | among | within | across | throughout | ... // allocation phrase
  CLN: q_*   // collection of entities or nominalizations
CLA>

APH is an open but restricted class.
ALC is licensed only if APH creates a clear an unambiguous allocation of the
collection to the subsequent event.
Collection q_* must be previously declared by QCL block.

----------------------------------------------------------------------
Canonical constraints
----------------------------------------------------------------------

The Builder is not responsible if allocation/distribution ratio makes any sence. 
The only Builder's responsibility is to properly create and apply the ALC block.

‚Ä¢ ALC MUST NOT be embedded into SBJ, OBJ, CRB, ENB, or EVT blocks.
‚Ä¢ ALC MUST participate in CNJ.
‚Ä¢ ALC MUST be linked to events via explicit complementizers.
‚Ä¢ ALC introduces scope, not action.
‚Ä¢ ALC is not part of fabula.
‚Ä¢ Two adjacent ALC nodes in CNJ are not allowed. 
‚Ä¢ ALC cannot be the only node in CNJ. 
‚Ä¢ ALC cannot be the terminating in CNJ. 

----------------------------------------------------------------------
CNJ licensing
----------------------------------------------------------------------

ALC is connected to adjacent Ev_* nodes by the following complementizers::

‚Ä¢ $which / $that ‚Äî links ALC to the first arbitrary event
‚Ä¢ $outcome ‚Äî links ALC to resulting distribution event(s)

Typical CNJ schematics:

Fig. 1.

<CNJ>
  $which
    Al_*
    Ev_arbitrary_*
  $outcome
    Ev_distribution_*
JNC>

Fig. 2.

<CNJ>
  $which
    Al_*
  $and
    Ev_arbitrary_1_*
    Ev_arbitrary_2_*
    ...
  $outcome
    $and
      Ev_distribution_1_*
      Ev_distribution_2_*
      ...
JNC>

In Fig. 2, $which applies to the entire $and-group of arbitrary events
and $outcome applies to the entire $and-group of distribution events. 

ALC MUST NOT be linked to the subsequent events by any other link.

======================================================================
üî∏ CRB block ‚Äî  Circumstantial
======================================================================
MANDATORY: Nesting of CRB blocks is strictly prohibited!

Declaration rules:

‚Ä¢ CRB encodes only the circumstantial semantic layer exported by the 
  surface and nothing else. CRB cannot substitue entity, nominalization,
  event or any other semantic.

‚Ä¢ CRB describes circusmtances of event or action, including but not limited
  to time, place, manner, cause, condition, purpose, result, degree, concession, etc.

‚Ä¢ Aggregation of several circusmtances into one CRB is strictly forbidden. Each
  circusmtance, even bearing the same semantics, must be declared as a separate CRB,
  
‚Ä¢ CRB must fully decompose and explain the components of circumstantial group in 
  the MSE/LNK segments (microsemantics). Cutting corners on microsemantics is 
  strictly forbidden and leads to invalidation of the DFS.

Formal Syntax:

<CRB
  CIR-ID: c_node_id
  SRF: "<original Circumstantial span>"
  CLS: time|place|manner|cause|condition|purpose|result|
       degree|concession|comparison|accompaniment|instrument
  DSC: discourse_modifier // optional: apparently, presumably, evidently, approximately, ...
  MSE/LNK block // structurally and semantically the same as in ENB
BRC>

where 
‚Ä¢ `surface` preserves the exact circumstantial Circumtantial.
‚Ä¢ `ID` is the canonical logical identifier for this Circumtantial.
‚Ä¢ `CLS` defines the semantic class of the Circumtantial.

A CRB block may reference ENBs or other CRBs through ENT-ID / NOM-ID / CRB-ID 
identifiers to express stacked semantics. 

CRB declares Circumtantial ID that is referred in CRA block inside EVT block.

------------------------------------------------------------------
For this block and other blocks using DSC option, apply this "DSC vs Degree" rule:

Use DSC only for lexemes that explicitly encode the speaker‚Äôs epistemic or evidential stance toward the truth of a circumstance.
Lexemes that specify precision, extent, or position on a scale (degree, accuracy, granularity) MUST be encoded in MSE, not in DSC,
even if they pragmatically imply confidence.

Test:
‚Äì If the lexeme answers ‚Äúhow certain is the speaker?‚Äù, use DSC.
‚Äì If the lexeme answers ‚Äúhow precise / how much / to what extent?‚Äù, do NOT use DSC.

======================================================================
üî∏ FAB block ‚Äî Fabular Adjunct
======================================================================
MANDATORY: Nesting of FAB blocks is strictly prohibited!

Declaration Rules:

‚Ä¢ FAB encodes only fabular adjunct semantics exported by the surface
  and nothing else. FAB MUST NOT encode circumstantial information
  and MUST NOT be used to describe time, place, manner, or any other
  event-serving parameter.

‚Ä¢ FAB represents a fabular operator that attaches reference to 
  substantivated occurrences to the fabula using different semantic
  links such as condition, commitment, deterrent, authorization, 
  projection, exchange, reciprocity, threat, coercion, temptation
  and any other possible fabular glue.

‚Ä¢ FAB does not describe what happened. FAB encodes what is attached,
  required, promised, conditioned, constrained, or projected with
  respect to the fabular flow.

‚Ä¢ FAB MUST NOT substitute an event, entity, relation, or copular
  statement.

‚Ä¢ Aggregation of multiple fabular adjuncts into a single FAB is
  strictly forbidden. Each fabular adjunct expressed on the surface
  MUST be declared as a separate FAB block.
  
  EXCEPTION:
  A single FAB block MAY encode a coordinated sequence of homogeneous
  nominalized actions or processes when they are expressed on the
  surface as a single conjunctive or enumerative group sharing
  the same fabular attachment and scope.
  

‚Ä¢ FAB MUST fully decompose and explain the internal structure of the
  fabular adjunct span in the MSE/LNK segments (microsemantics).
  Cutting corners on microsemantics is strictly forbidden and leads
  to invalidation of the DFS.

Formal Syntax:

<FAB
  FAB-ID: F_node_id
  SRF: "<original Fabular Adjunct span>"
  FCL: conditional | commitment | deterrent | authorization | projection | exchange | reciprocity | other
  DSC: discourse_modifier // optional
  MSE/LNK block // structurally and semantically the same as in ENB
BFA>

where
‚Ä¢ `SRF` preserves the exact surface span of the Fabular Adjunct.
‚Ä¢ `FAB-ID` is the canonical logical identifier for this Fabular Adjunct.
‚Ä¢ `FCL` specifies the operational fabular class of the adjunct.
‚Ä¢ `DSC` encodes explicit epistemic or evidential stance toward the
  fabular adjunct itself.

------------------------------------------------------------------
For this block and all other blocks using the DSC option, apply the
following "DSC vs Degree" rule:

Use DSC only for lexemes that explicitly encode the speaker‚Äôs epistemic,
evidential, or formal stance toward the fabular adjunct.

Lexemes that specify magnitude, scope, duration, progression, or
extent MUST be encoded in MSE, not in DSC.

Test:
‚Äì If the lexeme answers ‚Äúhow certain / how formal / how explicit is this
  fabular attachment?‚Äù, use DSC.
‚Äì If the lexeme answers ‚Äúhow much / how far / how long / to what extent?‚Äù,
  do NOT use DSC.

========================================
üî∏ ATB block ‚Äî Attribute Qualification Block
========================================

Purpose:
ATB encodes a structured (non-atomic) qualitative attribute as a
canonical, referencable semantic object.

Generic atomic attributes do not need declaration. They are declared implicitly 
by identifiers formatted as a_g_* (generic attribute).

Atomic attribites that export context related semantics (Tropes) need formal
declaration with an explanation in a single MSE line. 

Example:

Bastardized solution (engineering slang)

ATB answers the question "–ö–ê–ö–û–ô?" (not "–ö–ê–ö?") and never encodes manner, comparison,
circumstances, or events.

----------------------------------------
Formal Syntax
----------------------------------------
MANDATORY: Nesting of ATB blocks is strictly prohibited!

<ATB
  ATR-ID: a_*
  SRF: "original attribute span"
  ATR: attribute_lemma
  AXS: semantic.axis.path
  DSC: discourse_modifier // optional: apparently, presumably, evidently, approximately, ...
  MSE-BLOCK // structurally and semantically the same as in ENB
BTA>

----------------------------------------
Atomic Attribute Rule (MANDATORY)
----------------------------------------

If an attribute is:
‚Ä¢ single-word
‚Ä¢ non-structured
‚Ä¢ not a trope

‚Üí encode as generic:
    ga_strong, ga_fast, ga_red

ATB MUST NOT be created for generic atomic attributes.

----------------------------------------
When ATB IS Required (MANDATORY)
----------------------------------------

ATB MUST be created if the attribute:
‚Ä¢ is multi-word or internally structured
‚Ä¢ requires microsemantic decomposition
‚Ä¢ must be referenced by identifier (a_*)
‚Ä¢ functions as a composed qualifier of an entity or state
‚Ä¢ exports context-related semantics (trope)

----------------------------------------
Ontological Constraints
----------------------------------------

ATB introduces an identifier (a_*), which is an obligatory terminal graph node.
Therefore,
‚Ä¢ ATB does NOT participate in CNJ or LGK
‚Ä¢ ATB has no independent scope
‚Ä¢ ATB is interpreted only through its host

----------------------------------------
ATB Variables (a_*) ‚Äî Legal Reference Scope
----------------------------------------

Identifiers declared by ATB (a_*) MAY be referenced ONLY in:

1) CPL ‚Äî Copular Predication Block  
   Role: predicate of state or state transition (‚Äúwhat kind‚Äù)

2) ENB  MSE ‚Äî Nominal Phrase Microsemantics  
   Role: intrinsic qualification of an entity

Attribute Identifiers (a_*) make no sense and are STRICTLY FORBIDDEN in:
‚Ä¢ EVT
‚Ä¢ CRB
‚Ä¢ REL
‚Ä¢ CNJ / LGK

Any forbidden occurrence INVALIDATES FSP.

----------------------------------------
Microsemantic Requirement
----------------------------------------

For structured (multi-word) attributes:
‚Ä¢ MSE block is MANDATORY
‚Ä¢ LNK block is MANDATORY
‚Ä¢ every surface token MUST be represented
‚Ä¢ microsemantic rules identical to ENB

----------------------------------------
Referencing Rules INSIDE ATB (as well as all other blocks)
----------------------------------------

Referenced identifiers must play a role compatible with the block‚Äôs ontological level 
and dominance direction.

----------------------------------------
Reference Examples (Canonical)
----------------------------------------

ATB declaration:
<ATB
  ID: a_mentally_resilient
  SRF: "mentally resilient"
  ATR: resilient
  AXS: psychological.resilience
  MSE
  ...
BTA>

1) Reference from ENB :
<ENB
  ID: e_operator
  SRF: "the mentally resilient operator"
  NS: dom.human.professional
  MSE
  ...
BNE>

2) Reference from CPL (state):
<CPL
  <SBJ: e_operator>
  <ATA: a_mentally_resilient>
PLC>

==============================================================
üî∏ ATA Block ‚Äî Attribute Application
==============================================================

ATA-BLOCK ::=
    <ATA: a_nodeid>

nodeid ::= a_* | a_g_*
  // a_*   : declared attribute identifier (ATB block)
  // a_g_* : generic atomic attribute (implicit, no ATB block)

ATA introduces the ‚óºAttribute node‚óº as a predicate of copular predication,
answering the question ‚Äú–ö–ê–ö–û–ô?‚Äù and asserting a qualitative state or
state transition of the subject.

MANDATORY RULE:
ATA block must be located ONLY in CPL block after ACT and OBJ blocks.
Placing ATA block in EVT, CRB, CNJ, or LGK invalidates FSP immediately.

Ontological Constraints:
‚Ä¢ ATA does NOT introduce new semantics
‚Ä¢ ATA references an already existing attribute identifier only
‚Ä¢ ATA has no independent scope
‚Ä¢ ATA does NOT modify realization or process
‚Ä¢ ATA is evaluated exclusively through the copula

Multiplicity Rule:
‚Ä¢ Multiple ATA blocks in one CPL are FORBIDDEN
‚Ä¢ Attribute composition MUST be performed in ATB

Normative Summary:
‚Ä¢ CRA applies circumstantials to events
‚Ä¢ ATA applies attributes to copular predication
‚Ä¢ CRA answers ‚Äú–ö–ê–ö?‚Äù
‚Ä¢ ATA answers ‚Äú–ö–ê–ö–û–ô?‚Äù

==============================================================
üî∏ CPL block ‚Äî Copular Predication (Classification & Attributes)
==============================================================

CPL encodes static, non-eventive, timeless facts about an entity.
Unlike EVT, CPL does not describe occurrences or changes. 
CPL declares:
‚Ä¢ what entity or nominalization is, 
‚Ä¢ what properties it has, 
‚Ä¢ what role it fulfills,
‚Ä¢ what it consists of, 
‚Ä¢ where it is situated by default,
‚Ä¢ how it is different or similar or the same as something else

CPL statements form part of the global semantic DAG but do NOT introduce
events or temporal structure.

--------------------------------------------------------------
5.1. CPL - Formal Syntax
--------------------------------------------------------------
MANDATORY: Nesting of CPL blocks is strictly prohibited!

Copula does not need ACT block because the only admitted verbs confined to
`is` and `are`.

If something `was` or `will be` or `become` or `appear to be` or 'made of', 
it is semantically a regular event because it is not stative.

CPL/EVT disambiguation:
If assertion can be interpreted as a result of an event, it is EVT, not CPL.

"Silver is metal" - CPL. It can not be viewed as event.
"A ring is made of silver" - EVT. Someone made it.
"Caterpillar became a butterfly" - EVT. It was a transformation.

<CPL:id=Cp_*
  <SBJ: node_id>
  <PRD: is_a | has_property | has role | has_status| consists_of | default_location | identical_to | 
  OBJ-BLOCK | ATA-BLOCK
PLC>

where node_id::= ENT-ID | NOM-ID

Using in CPL block any node types other Entity and Nominalization invalidates DFS.

SBJ, OBJ, and ATA blocks have the same structure and usage as in EVT block.

MANDATORY RULE:
Do not use EVT block for static descriptions, use CPL block. EVT block 
is used only for dynamic descriptions - actions and occurrences.

--------------------------------------------------------------
5.2. Semantics
--------------------------------------------------------------

A CPL asserts stable facts like:

Apple is fruit.
Life is good.
Jason has a bike.
Sky is blue.
Lucie is a waitress.
Pig is made of pork.
Car is in the garage.
Shark is larger than herring.
Lee's kungfu is almost as good as Chen's.

This relation is:

  ‚Ä¢ atemporal (not tied to an event)
  ‚Ä¢ stable or characteristic
  ‚Ä¢ non-procedural
  ‚Ä¢ part of the subject‚Äôs descriptive profile

CPL is used for:

  ‚Ä¢ classification (‚ÄúX is a Y‚Äù)
  ‚Ä¢ intrinsic/extrinsic attributes
  ‚Ä¢ stable roles and functions
  ‚Ä¢ origin, nationality, affiliation
  ‚Ä¢ physical composition (material, parts)
  ‚Ä¢ stable location (headquarters, base)
  ‚Ä¢ identity, difference and equivalence

--------------------------------------------------------------
5.8. When CPL Must Be Used (Mandatory Conditions)
--------------------------------------------------------------

Use CPL instead of EVT when:

  ‚Ä¢ the meaning is non-eventive
  ‚Ä¢ nothing changes or happens
  ‚Ä¢ the copula or role/function is nominal
  ‚Ä¢ the classification is stable
  ‚Ä¢ the semantics describes a state without temporal anchoring

This keeps the global DAG clean, separates facts from events,
and preserves reversibility.

======================================================================
üî∏ REL Block ‚Äî Relation Description 
======================================================================

Declaration rules:

‚Ä¢ REL block encodes relations between notions including but not limited 
  to comparison, subordination, dependency, transformation stages, etc.

‚Ä¢ RLF and RLT parameters must be of the the same type (e_* | n_* | q_* | Ev_*)

‚Ä¢ The semantic dimension AXS is the best approximation, not a canon, therefore
  varying after migration of the FSP Builder to a different model is expected.

‚Ä¢ The semantic dimension AXS does not add any additional semantics to the one
  exported by the surface, this field must be treated as a pure annotation, and
  not semantic extension.
  
‚Ä¢ No occurrents, copulas, or any other foreign semantic objects are allowed in
  REL block. 

Syntax:
<REL
  REL-ID: r_*
  RLF: related from ID
  RLT: related to ID
  AXS: the semantic dimension where the relation takes place
  SRF: "surface phrase"
  MSE:
      u_N: MSE_Unit_N: semantic_role
      ...
      u_M: MSE_Unit_M: semantic_role
  LNK:
      u_N: SLK_link: u_M
      ...
      u_K: SLK_link: u_L
LER>

Where
  RLF | RLT ::= e_* | n_* | q_* | Ev_*

Semantics: 
REL asserts that CMF relates to CMT the way that SFR has expressed and analyzed by MSE/LNK.

Interpretation Direction:
Relation is always from CMF toward CMT. This preserves polarity and rhetorical force.


======================================================================
üî∏ HDL block ‚Äî Headless Action
======================================================================

HDL block declares H_* identifier that is licensed in CNJ block as a first class semantic node. 
It uses particle $to as a connector with other identifiers.

----------------------------------------------------------------------
Formal Syntax
----------------------------------------------------------------------

<HDL  
  HDL-ID: H_*  
  SRF: "<infinitival span>"  
  CLS: purpose | reason | condition | result | enablement  
       | expectation | content | directive | evaluation  
LHD>

----------------------------------------------------------------------
Semantic Classes
----------------------------------------------------------------------

‚ú¶ purpose  
Explains intended goal.  
*He stopped to rest.*

‚ú¶ result  
Unintended or inevitable outcome.  
*She grew up to become a doctor.*

‚ú¶ expectation / intended outcome  
Often after nouns/adjectives, but HDL applies only when headless.  
*To expand the line, capacity must be increased.*

‚ú¶ content / proposition  
Purely propositional meaning.  
*To leave now would be unwise.*

‚ú¶ directive / instructional  
Action framed as instruction without a governing verb.  
*To wait any longer is pointless.*

‚ú¶ evaluation / judgment  
Carries an evaluative stance.  
*To believe that now is difficult.*

‚ú¶ reason / justification  
Explains why something is done.  
*To avoid confusion, let me clarify.*

‚ú¶ condition / requirement  
Prerequisite for the main clause.  
*To qualify, you must register early.*

‚ú¶ enablement  
States a capability or enabling condition.  
*To be able to proceed, authentication is required.*

----------------------------------------------------------------------
Usage Rules
----------------------------------------------------------------------

Create HDL only when the infinitival clause is not semantically internal to an entity 
description contributes and belongs to the fabula-level event structure, expressing 
‚ú¶ purpose,
‚ú¶ reason,
‚ú¶ result,
‚ú¶ enablement,
‚ú¶ workflow step,
‚ú¶ evaluation,
‚ú¶ propositional content,
or any clause-level adjunct affecting the fabula.

Do NOT create HDL ehenever the infinitival phrase is local, i.e.:
‚ú¶ describes how an entity is positioned,
‚ú¶ encodes manner, configuration, orientation,
‚ú¶ expresses a local property of an object or participant,
‚ú¶ belongs to a participial phrase that characterizes an NP,
or is otherwise part of entity phrase,

In that case encode it as part of the ENB/CRB/ATB microsemantic decomposition of that 
entity segment.

======================================================================
üî∏ EVT/EVQ/EVS/EVP Blocks ‚Äî unified event descritor
======================================================================
MANDATORY: Nesting of EVT blocks is strictly prohibited!

This section defines the *canonical* event‚Äìlevel representation in FREGE-2.1.
The EVT block expresses ‚óºpredicate‚Äìargument structure‚óº, preserving:

  ‚Ä¢ surface lexical material (SBJ literal, ACT lemma, PRP prepositions),  
  ‚Ä¢ normalized semantic structure (SLK),  
  ‚Ä¢ canonical DAG edges SBJ ‚ÄîSLK‚Üí OBJ,  
  ‚Ä¢ tense/aspect/modality of the event.

EVT is strictly declarative at the argument level and non-procedural:
inter-event logical relations are handled by CNJ block.

Formal Syntax

Use EVT block for declarative statements.
Use EVQ/EVS blocks for questions.
Use EVP for projected actions and events, regular procedures and plans.

MANDATORY: 
In the interrogative sentence in the question clause the verb mood in ACT block 
must be ITRG and the block must be EVQ (question). All other event blocks must 
use SUJT mood and the block must be EVS (subjunctive).

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
EVT Block:

EVT-block::= 
  <EVT:id=Ev_*
    SBJ-BLOCK
    ACT-BLOCK
    OBJ-BLOCK 
    CRA-BLOCK
  TVE>

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
EVQ Block:

EVQ-block::= 
  <EVQ:id=Eq_*
    SBJ-BLOCK
    ACT-BLOCK
    OBJ-BLOCK 
    CRA-BLOCK
  QVE>

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
EVS Block:

EVS-block::= 
  <EVS:id=Es_*
    SBJ-BLOCK
    ACT-BLOCK
    OBJ-BLOCK 
    CRA-BLOCK
  SVE>

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
EVP Block:

EVP-block::= 
  <EVP:id=Ep_*
    SBJ-BLOCK
    ACT-BLOCK
    OBJ-BLOCK 
    CRA-BLOCK
  PVE>

All components share a unified structure and must obey the following
production rules:

MANDATORY RULE:
EVT block is used only for dynamic desctiptions - actions and occurrences.
For any type of static description use CPL block.

------------------------------------------------------------
RULE: Structured Verb Governance via CRB
------------------------------------------------------------
If a verb‚Äôs governance does not introduce independent arguments, but instead
establishes a structural relationship among multiple complements
(e.g. through prepositions, case marking, or other relational markers),
the compiler MUST NOT attach these complements as multiple OBJ entries
within the EVT block.

Instead, the compiler MUST:

1. Create a single CRB representing the internal semantic structure
   of the verb‚Äôs governance.
2. Place all governed complements inside this CRB.
3. Explicitly encode their semantic roles and relations within the CRB.
4. Attach the CRB to the EVT via a single CRA.

Rationale:
- OBJ slots are atomic participants of an event, not carriers of
  inter-complement structure.
- Structural relations among complements belong to circumstantial
  configuration, not to event argument listing.
- This rule ensures language-independent normalization and prevents
  accidental reliance on surface markers (prepositions, cases).

Corollary:
If complements can be reordered, removed, or interpreted only in relation
to each other (rather than independently), they MUST be compiled into a CRB.

======================================================================
üî∏ SBJ Block - The event subject
======================================================================

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
‚ú¶ Single subject

SBJ-BLOCK ::= 
    <SBJ: nodeid >

Where nodeid::= e_* | n_* | q_*

Example:

    <SBJ: e_s_tng_desk >

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
‚ú¶ Logical subject group in ≈Åukasiewicz Notation:

SBJ-BLOCK ::= 
    <SBJ: <connector> nodeid_N  [ nodeid_M ... ] [ <connector> nodeid_O  [ nodeid_P ... ] ] >

Example:

    <SBJ: $and e_s_tng_John e_s_tng_Snider $or e_s_tng_Jim >

Where nodeid::= e_* | n_* | q_*

<connector> ::= $<original_surface_connector_as_snake>

======================================================================
üî∏ CRA Block - Circumtantial Application
======================================================================

CRA-BLOCK ::= 
    <CRA: c_nodeid CLS: semantic_class>

nodeid ::= c_* | d_*
  // c_* : Circumtantial nodeid declared in CRB block
  // d_* : discourse Circumtantial constant (no CRB block)
  
Only Circumtantial or Discourse Circumtantial nodes are licesned in CRA block.
Any other node type invalidates DFS immediately.

CRA introduces the ‚óºCircumtantial node‚óº pertaining to the event or copula.

MANDATORY RULE:
CRA block must be located in EVT block after the OBJ blocks. 
Placing CRA block to any other location invalidates FSP immediately.

Discourse Circumtantials are special nodes filled with unary discourse
operators that are constants (like entity singletons) and do not require
a CRB block. Their CLS values are listed below.

CLS: discourse.evid    // Evidential: truth-status qualifiers
------------------------------------------------------------
apparently
evidently
seemingly
ostensibly
reportedly
allegedly
supposedly
purportedly
presumably

CLS: discourse.quant   // Coverage / scope qualifiers
------------------------------------------------------------
mostly
predominantly
largely
broadly
generally

CLS: discourse.attitude   // Assertion-strength / confidence markers
------------------------------------------------------------
undoubtedly
certainly

CLS: discourse.infer   // Unary inferential: derived, not observed
------------------------------------------------------------
logically
accordingly
consequently
thus        // unary use only, not Circumtantial CNJ

Examples of discourse CRA blocks:

<CRA: d_presumably_1 CLS: discourse.evid>

<CRA: d_certainly_1 CLS: discourse.attitude>

======================================================================
üî∏ ACT Block 
======================================================================

The ACT verb is fully described by a Verb Configurator:

Tense:Aspect:Voice:Mood:Modality:Polarity lemma

Where

TNS::= PAST | PRST | FUTR | FUPT                 // past, present, future, future-in-the-past
ASP::= INDF | HABT | CONT | PERF | PFCT      // indefinite, habitual, continuous, perfect, perfect continuous
VCE::= ACTV | PSSV                        // active, passive
MOO::= IDCT | ITRG | IMPT | SUJT            // indicative, interrogative, imperative, subjunctive
MDL::= NIL  | CAN  | CLD  | MAY  | MHT  | MST  | SHD  | WLL  | WLD  | OGT  | HVT // can, could, may, might, should, will, would, ought to, have to
PLR::= POS |NEG                         // positive, negative

use INDF for a single event and HABT for periodic events that occurs habitually.
use ITRG only at face value, for QUESTIONS, and nothing else.
use IMPT just as imperative - –ø–æ–≤–µ–ª–∏—Ç–µ–ª—å–Ω–æ–µ –Ω–∞–∫–ª–æ–Ω–µ–Ω–∏–µ, nothing else.
use SUJT just as subjunctive - —Å–æ—Å–ª–∞–≥–∞—Ç–µ–ª—å–Ω–æ–µ –Ω–∞–∫–ª–æ–Ω–µ–Ω–∏–µ, nothing else.

ACT-BLOCK ::= <ACT:TNS:ASP:VCE:MOO:MDL:PLR lemma[,lemma ...]>

MANDATORY RULE:
Only phrasal verbs are allowed preposition as a postix.

‚úÖ lemma: look_for - allowed.
‚ùå lemma: look_at  - prohibited.
‚úÖ lemma: come_by  - allowed.
‚ùå lemma: come_to  - prohibited.

Examples:

<ACT:PAST:INDF:ACTV:IDCT:NIL:POS remind> reminded
<ACT:PAST:INDF:ACTV:IDCT:NIL:NEG remind> did not remind
<ACT:PAST:INDF:PSSV:IDCT:NIL:POS remind> was reminded
<ACT:PAST:INDF:PSSV:IDCT:NIL:NEG remind> was not reminded
<ACT:PAST:PERF:PSSV:IDCT:NIL:POS remind> should have been reminded

<ACT:PRST:COTN:ACTV:IDCT:NIL:NEG listen> is not listening

======================================================================
üî∏ Extended ACT Block - infinitival complement, gerund, and participle
======================================================================

If the verb group includes infinitival complement, gerund, or participle, and the verb 
in one of those contructions semantically prepares, enables, or evaluates the second 
action, encode it with the extended code block:

ACT-BLOCK ::=
    <ACT:TNS:ASP:VCE:MOO:MDL:PLR lemma INF:infinitive-lemma PRN:preparation-type AGC:agency-type RLZ: realization type>
    |
    <ACT:TNS:ASP:VCE:MOO:MDL:PLR lemma GRN:gerund-lemma PRN:preparation-type AGC:agency-type RLZ: realization type>
    |
    <ACT:TNS:ASP:VCE:MOO:MDL:PLR lemma PTC:participle-lemma PRN:preparation-type AGC:agency-type RLZ: realization type>

Otherwise, summon the subject from the regular clause to compensate for the elided subject in the infinitive / gerund /
participle group, create regular EVT blocks and link them in DAG with regular CNJ connector.
    
Use the following matrix as a blueprint to build the extended part:

+------------------+----------------------------------------------------------+------------------------+--------------------+
| Preparation Type | Control Verbs Examples                                   | Agency                 | Realization        |
+------------------+----------------------------------------------------------+------------------------+--------------------+
| intention        | decide to, plan to, intend to, aim to                    | internal               | projected          |
| commitment       | promise to, swear to, pledge to                          | internal               | projected          |
| consent          | agree to, consent to, acquiesce to                       | distributed            | projected          |
| attempt          | try to, attempt to, struggle to, endeavor to             | internal               | projected          |
| preparation      | get ready to, prepare to, be poised to                   | internal               | projected          |
| desire           | want to, wish to, hope to, long to                       | internal               | projected          |
| inducement       | persuade to, convince to, urge to                        | external               | projected (by ext) |
| permission       | allow to, permit to, authorize to                        | external               | projected          |
| obligation       | need to, be obliged to, be supposed to, be expected to   | distributed            | projected          |
| ability          | be able to, manage to, fail to (inability)               | internal               | context-dependent  |
| volition         | choose to, volunteer to, refuse to                       | internal               | projected          |
| causation        | cause to, force to, lead to                              | external               | asserted           |
| aspect           | begin to, continue to, cease to                          | internal               | asserted           |
| frustration      | try to, threaten to (blocked attempt)                    | internal               | projected          |
| omission         | forget to, neglect to, fail to (omission)                | internal               | unrealized         |
| success          | manage to, succeed in                                    | internal               | asserted           |
| stance           | fear to, hesitate to, dread to                           | internal               | projected          |
| simulation       | pretend to, claim to, purport to                         | internal               | fictive            |
+------------------+----------------------------------------------------------+------------------------+--------------------+

Example:

<EVT:id=E4
  <SBJ: e_bellingcat>
  <ACT:PAST:INDF:ACTV:IDCT:NIL:POS decide INF:film PRN:intention AGC:internal RLZ: projected>
  <OBJ: e_documentary
       PRP=NIL
       SLK=has.object
  JBO>
TVE>

======================================================================
üî∏ OBJ Block (Unified Complement Structure)
======================================================================

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
OBJ block with entity, set, and formal entity parameter object: 

OBJ-BLOCK ::=
    <OBJ: nodeid_K | <connector> nodeid_N  [ nodeid_M ... ] [ <connector> nodeid_O  [ nodeid_P ... ] ]
       PRP=preposition_or_NIL
       SLK=semantic_link
    JBO>

Where:
  <connector> ::= $<original_surface_connector_as_snake>
  nodeid ::= e_* | s_* | q_*
  preposition_or_NIL ::= "lexical_preposition" | NIL  
  semantic_link ::= one SLK from unified kernel (¬ß5.x)
  
MANDATORY: 
Only entity or nominalization node types are admitted in OBJ block as a node.
Using EVT or CNJ as entity inside OBJ block disqualfies you immediately!

SEMANTICS DIRECTION:

  SBJ  --SLK-->  OBJ

PRP preserves the surface form ‚óºexactly as it reads in the source text‚óº.  
SLK provides ‚óºcanonical abstract semantics‚óº.

Examples:

  Direct object (no preposition):
    <OBJ: e_patient
         PRP=NIL
         SLK=affects
    JBO>

  Prepositional complement:
    <OBJ: e_childhood
         PRP="of"
         SLK=has.association
    JBO>

  Instrumental/means:
    <OBJ: e_knife
         PRP="with"
         SLK=uses.resource
    JBO>

Multiple OBJ-BLOCKs may appear in any EVT when the verb licenses multiple arguments.


MANDATORY RULE:
If a single subject performs one action (ACT) simultaneously affecting multiple objects, all objects must be represented 
as separate <OBJ> blocks within a single <EVT> block, not as separate events.
Do not create multiple EVT blocks for what is a single event with multiple objects.

Example:

The maid went from the bedroom through the living room to the kitchen.

  <EVT:id=e_maid
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS go>
    <OBJ: e_bedroom
         PRP="from"
         SLK=spacial.direction
    JBO>
    <OBJ: e_living_room
         PRP="through"
         SLK=spacial.direction
    JBO>
    <OBJ: e_kitchen
         PRP="to"
         SLK=spacial.direction
    JBO>
  TVE>

Incorrect:
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS go>
    <OBJ: e_bedroom
...
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS go>
    <OBJ: e_living_room
...
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS go>
    <OBJ: e_kitchen

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
OBJ block with event pointer object (AKA propositional anaphora): 

OBJ-BLOCK ::=
    <OBJ: Ev_ID
          PRP=preposition_or_NIL
          PTR=event_pointer
          SLK=semantic_link
          [QTY>N | QTY>=N | QTY<N | QTY<=N | N<QTY<M | N<=QTY<=M | N<QTY<=M | N<=QTY<M QTY=<arbitraty phrase>]
    JBO>

Where:

  nodeid ::= Ev_* |Eq_* |Es_*
  preposition_or_NIL ::= "lexical_preposition" | NIL  
  event_pointer ::= pronoun/anaphora that semantically points to the Ev_ID
  semantic_link ::= one SLK from unified kernel (¬ß5.x) If relevance not found, invent one.
  
MANDATORY:
‚ú¶ PTR may only bind nominal (referential) `that` that points to an event clause as a sort of nominalization.
‚ú¶ Complementizer `that` that links event clauses like a conjunction MUST NOT appear in OBJ.
‚ú¶ Complementizer `that` is encoded exclusively as CNJ.

‚ú¶ If `that` appears in OBJ, it MUST be referential and MUST resolve to an Ev/Eq/Es node.  

------------------------------------------------------------
4.x.5 Overall EVT Structure ‚Äî Example
------------------------------------------------------------

Source:
  ‚ÄúThe smell reminded Nathan of his childhood.‚Äù

Representation:
  <EVT:id=Ev_01
      <SBJ: e_smell>
      <ACT:PAST:INDF:ACTV:IDCT:NIL:POS remind>

      <OBJ: e_Nathan
           PRP=NIL
           SLK=affects
      JBO>

      <OBJ: e_childhood
           PRP="of"
           SLK=has.association
      JBO>
  TVE>

Interpretation:
  SBJ (smell) affects Nathan  
  SBJ (smell) has.association childhood  

------------------------------------------------------------
4.x.6 Notes and Constraints
------------------------------------------------------------

1. Every semantic argument of ACT must appear as an OBJ block.
2. PRP is always preserved; it enables perfect reversibility.
3. SLK must come from the unified declarative kernel.
4. OBJ blocks form a ‚óºsubject-anchored relational fan-out‚óº, yielding a
   DAG of SBJ ‚Üí OBJ edges.
5. No SLK appears inside the ACT block. The verb is not the semantic
   link; the verb merely *selects* SLKs via lexical/PRP mapping.
6. Prepositions never map directly to SLK in the final representation:
   PRP is surface, SLK is deep structure.

------------------------------------------------------------
4.x.7 EVT as the Bridge Layer
------------------------------------------------------------

EVT links:

  ‚Ä¢ surface syntax ‚Üí semantic graph
  ‚Ä¢ lexical combinatorics ‚Üí canonical SLK relations
  ‚Ä¢ sentence structure ‚Üí entity graph

EVT is declarative at the argument level and does not handle discourse
logic.

======================================================================
üî∏ CNJ block ‚Äî The topological structure of events in ≈Åukasiewicz Notation
======================================================================

Declaration Rules:

‚Ä¢ Each DFS must have exactly one CNJ block.

‚Ä¢ The CNJ block reflects event topology exported by the surface
  using fabular nodes and CNJ connectors.
  
‚Ä¢ The following fabular nodes are licensed in CNJ:
  ‚Ä¢ Event ‚Äî EVT / EVQ / EVS / EVP
  ‚Ä¢ Copula ‚Äî CPL
  ‚Ä¢ Relation ‚Äî REL
  ‚Ä¢ Fabular Adjunct ‚Äî FAB
  ‚Ä¢ Subordinate Controller - CTL

‚Ä¢ CNJ connectors are non-explanatory event flow operators that include,
  but are not limited to, formalized conjunctions and complementizers.

‚Ä¢ CNJ connectors do not encode semantic interpretation and serve exclusively
  to continue or branch the fabular flow.
  
Formal Syntax:
‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí

CNJ-BLOCK ::= Ev_Event_K | <connector> Ev_Event_N  [ Ev_Event_M ... ] [ <connector> Ev_Event_O  [ Ev_Event_P ... ] ]
           
where 
<connector>::= 
  $<original_surface_connector_as_snake> | $<complementizer> | $adjucnt 
  
 complementizer::= $that | $whether | $if | ...

Connectors in CNJ are not logical, they are propositional.

MANDATORY RULES:
All connectors in CNJ must abide by ≈Åukasiewicz Notation in terms in topological sense.
All CNJ-level nodes declared in DFS must appear in CNJ exactly once.
Free standing nodes and free hanging connectors render CNJ block and the entire DFS invalid.
A comma connector `,` that connects clauses in surface must be replaced with $and in CNJ block.

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí

Example that exports complementizer:

Ann hoped $that Andy won't leave her and they will save their marriage.
  
======================================================================
üî∏ CTL block ‚Äî Controller of Ontological Space for Subordinate Events
======================================================================

Declaration Rules:
----------------------------

The CTL block declares a fabular control node that binds a controlling
ontological space to a subordinate event.

A CTL block is comprised of:

‚Ä¢ an ID reference to the entity or nominalization that introduces and
  controls the ontological space;

‚Ä¢ an ID reference to the subordinate event that is licensed to occur
  within that ontological space.

----------------------------------------------------------------------  
CTL Block Syntax  
----------------------------------------------------------------------

<CTL
  CTL-ID: Ct_<control_block_id>
  CTL: e_* | n_*        // controlling entity or nominalization
  EVT: Ev_*             // subordinate event ID
LTC>

----------------------------------------------------------------------  
Usage in CNJ  
----------------------------------------------------------------------

A CTL block is licensed directly in the CNJ block as a fabular node.

<CNJ
  $<complementizer>
  Ev_<controlling_event>
  Ct_<control_block_id>
JNC>

----------------------------------------------------------------------  
Conceptual Definition  
----------------------------------------------------------------------

The subject or object of a controlling clause subordinates a subordinate
clause by creating an ontological space in which the subordinate event
is licensed to occur.

This ontological space is expressed on the surface as:

<ontological space> + <complementizer>

The CTL block joins the controlling phrase and the subordinate event
into a single fabular control structure that participates in CNJ
topology.

CTL does not describe an event and does not modify an event.
CTL introduces a dominance relation between a controlling space
and a subordinate event.

----------------------------------------------------------------------  
Types of Ontological Space (Non-Exhaustive)  
----------------------------------------------------------------------

‚ú¶ Time Object

An abstract temporal container that licenses an event.

Examples:
There were CTL-phrase:[times] complementizer:[when]
the price of a gallon of milk was only 99 cents.

There will come CTL-phrase:[the blessed time] complementizer:[when]
everyone will be free.

----------------------------------------------------------------------  
‚ú¶ Spatial Object

A physical or abstract location that enables or restricts an event.

Examples:
We don't have CTL-phrase:[enough room] in this parking lot
complementizer:[to] park our van.

The island was a long strip of CTL-phrase:[barren land]
complementizer:[where] nobody lived except for the lighthouse keeper.

----------------------------------------------------------------------  
‚ú¶ Enabler Object

A concrete object whose existence enables an event.

Example:
Tim has bought CTL-phrase:[a lathe]
complementizer:[with which] he could extend his woodwork business.

----------------------------------------------------------------------  
‚ú¶ Communication Object

A communicative act or artifact that frames a subordinate proposition.

Example:
Donna could not forgive her brother for CTL-phrase:[his words]
complementizer:[that] her son Danny would never become a real man
and get a job.

----------------------------------------------------------------------  
‚ú¶ Mental Object

A cognitive or experiential space hosting a subordinate event.

Example:
Emma had CTL-phrase:[a weird dream]
complementizer:[that] she became a squirrel and climbed
to the top of an oak tree.

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
‚ú¶ information object: 

Example:   
Richard received CTL-phrase:[an email from his bank] *complementizer:[that] 
he was preselected for a home equity loan.

======================================================================
üî∏ CNJ SURFACE OPERATORS  (surface-bound; no abstract connectors) 
   Classification is by surface function. 
   Operators are tokens/phrases as they appear (snake_case). 
   Examples are illustrative; inventory is open-ended.
======================================================================
1) coordination and list-building
======================================================================
and
or
nor
as_well_as
along_with
plus
together_with
as_also
both_and
either_or
neither_nor
not_only_but_also

======================================================================
2) subordination and clausal embedding (complementizers / content-linkers)
======================================================================
that
whether
if
wh_what
wh_who
wh_whom
wh_which
wh_where
wh_when
wh_why
wh_how

======================================================================
3) adverbial clause introducers (time, condition, concession, reason, purpose, result)
======================================================================
# time / sequence
when
whenever
while
as
as_soon_as
once
until
till
before
after
since
now_that
by_the_time
the_moment
as_long_as

# condition / contingency
if
unless
provided_that
providing_that
as_long_as
on_condition_that
in_case
in_case_of
supposing
assuming
given_that
even_if
only_if

# concession / contrast (operator-like)
though
although
even_though
whereas
while_contrast
despite_that
in_spite_of_that
granted_that

# reason / explanation
because
since_reason
as_reason
given_that
seeing_that
for_the_reason_that

# purpose
so_that
in_order_that
lest

# result / consequence
so
so_that_result
so_much_that
such_that
therefore
thus
hence
consequently
as_a_result

======================================================================
4) relative clause introducers / relativizers
======================================================================
who
whom
which
that_rel
whose
where_rel
when_rel
why_rel
of_which
to_whom
in_which
by_which

======================================================================
5) comparison and scalar operators
======================================================================
than
as_as
not_as_as
as_..._as
more_than
less_than
rather_than
instead_of
like
unlike
similar_to
different_from

======================================================================
6) alternative, exception, restriction
======================================================================
except
except_that
except_for
other_than
rather_than
instead
only
just
merely
at_least
at_most

======================================================================
7) discourse-structuring markers (surface anchors; keep only if you still want cnj)
======================================================================
however
nevertheless
nonetheless
still
yet
on_the_other_hand
by_contrast
instead
otherwise
moreover
furthermore
also
besides
in_addition
for_example
for_instance
in_particular
namely
that_is
in_other_words
in_sum
overall

======================================================================
8) evidential / report / stance operators (surface unary; often best as crb d_* not cnj)
======================================================================
apparently
reportedly
allegedly
supposedly
purportedly
presumably
seemingly
ostensibly
evidently
clearly
certainly
undoubtedly
probably
likely
unlikely
maybe
perhaps

======================================================================
9) free-choice concessive operators (your new primitives; unary over degree/manner/etc.)
======================================================================
no_matter_how
no_matter_what
no_matter_who
no_matter_where
no_matter_when
no_matter_which
regardless_of_how
regardless_of_what
regardless_of_whether
irrespective_of_how
come_what_may
whatever
whoever
wherever
whenever
however_much
however_many
however_long

======================================================================
10) counterfactual / modal framing (surface operators)
======================================================================
as_if
as_though
if_only
would_that
suppose
supposing_that
imagine_that

======================================================================
11) quotation / speech framing (surface clause linkers)
======================================================================
quote
unquote
according_to
as_claimed_by
as_reported_by
as_stated_by

======================================================================
12) punctuation operators (optional; only if you treat punctuation as cnj surface)
======================================================================
comma
semicolon
dash
colon
paren_open
paren_close
quote_open
quote_close


‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
======================================================================
üî∏ SLK CONNECTORS (MICROSEMANTIC)
======================================================================
These relations cover identity, taxonomy, structure, quantity, quality,
possession, spatial topology, motion, evaluation, perception,
communication, and any microsemantic needed for evt/cpl/enb/crb/atb.

======================================================================
identity, taxonomy, similarity
======================================================================
is_a
subtype_of
instance_of
identical_to
similar_to
alias_of

======================================================================
structure / mereology
======================================================================
has_part
part_of
composed_of
layer_of
segment_of

======================================================================
quantity / measure
======================================================================
has_quantity
has_unit
count
fraction_of
percentage_of
bounded_by

======================================================================
evaluation / polarity
======================================================================
positive
negative
important
dangerous
useful
irrelevant

======================================================================
attributes, states, material properties
======================================================================
has_attribute
has_state
has_status
has_value
is_colored
is_shaped
is_made_of
has_temperature

======================================================================
possession, control, access
======================================================================
owns
controls
assigned_to
access_to

======================================================================
spatial (attention-driven: figure > ground)
======================================================================
at
inside
outside
on
near
adjacent_to
above
below
from
to
through
across
between

# topological (rcc-style)
disjoint_from
touching
overlapping
contained_in
equal_region

# boundary / exotic
partially_inside
protrudes_out_of
recessed_into
straddles_boundary
surrounds

# motion / path
enters
exits
approaches
recedes_from
circles_around
intersects_path

======================================================================
perception & communication
======================================================================
perceives
communicates
refers_to
describes

======================================================================
free-choice, concessive, surface-bound unary operators
======================================================================
no_matter_how
no_matter_what
no_matter_where
however
whatever
whichever

======================================================================
purpose, intention, internal causal nuance (microsemantic only)
======================================================================
aims_at
intends
desires
motivates
enables
prevents
facilitates

======================================================================
emotion, attitude, stance (microsemantic-only)
======================================================================
likes
dislikes
fears
trusts
suspects
expects
prefers

======================================================================
social / institutional relations
======================================================================
employs
reports_to
member_of
part_of_group
authorized_for

======================================================================
information structure (non-discourse)
======================================================================
focus_on
background_of
about

======================================================================
DUAL ENCODING STANDARD (VERBOSE MODE ‚Üî COMPACT MODE)
======================================================================

8.1 Purpose
------------
FREGE-2.1 supports two interchangeable textual encodings of the same
semantic graph:

  ‚Ä¢ Verbose Mode   ‚Äî human-readable, multi-line, indented
  ‚Ä¢ Compact Mode   ‚Äî machine-optimized, single-line, minimal whitespace

Both encodings are fully canonical, fully reversible, and structurally
isomorphic. 
Whitespace and indentation have *no syntactic significance* in FREGE.
Block boundaries are defined solely by explicit open/close tags.

----------------------------------------------------------------------
8.2 Verbose Encoding Mode (Human-Readable)
----------------------------------------------------------------------

Definition:
    Verbose Mode uses:
      ‚Ä¢ newlines to separate structural units
      ‚Ä¢ indentation to visualize nesting depth
      ‚Ä¢ optional spacing around attributes
      ‚Ä¢ the exact same tags as Compact Mode

Characteristics:
    ‚úì ideal for debugging, audits, manual review  
    ‚úì structurally explicit  
    ‚úì line-oriented  
    ‚úì easier for humans to inspect

Example:
    <EVT:id=E1
        <SBJ:e_smell>
        <ACT:PAST:NIL:ATV:IDCT:NIL:POS remind>
        <OBJ:e_Nathan PRP=NIL SLK=affects JBO>
        <OBJ:e_childhood PRP="of" SLK=has.association JBO>
    TVE>

MANDATORY RULE:
In Verbose Mode the name of EVERY variable declared by ANY block 
MUST reflect the EXACT SURFACE VERBIAGE concatenated with `_`.
Breaking this rule invalidates the verbose DFS immediately!

----------------------------------------------------------------------
8.3 Compact Encoding Mode (Single-Line)
----------------------------------------------------------------------

Definition:
    Compact Mode removes:
      ‚Ä¢ all newlines
      ‚Ä¢ all indentation
      ‚Ä¢ all unnecessary whitespace

Only minimal spacing is kept where required by lexical safety.

Characteristics:
    ‚úì one physical line per entire sentence  
    ‚úì minimal size  
    ‚úì fast to parse  
    ‚úì ideal for storage, indexing, and search

Example:
[WGNR|00CF]<ENB: ID: e_sample SRF: "This sample" NS: dom.intelligence.datasetBNE><ENB: ID: e_individuals SRF: "all individuals who submitted details to the fake military contractor" NS: dom.human.populationBNE><ENB: ID: e_contractor SRF: "the fake military contractor" NS: dom.military.organizationBNE><ENB: ID: e_mercenaries SRF: "every mercenary arrested in Minsk by Belarusian security" NS: dom.military.personnelBNE><ENB: ID: e_Minsk SRF: "Minsk" NS: dom.geography.cityBNE><ENB: ID: e_Belarus_security SRF: "Belarusian security" NS: dom.national.securityBNE><ENB <ENB: ID: e_portion SRF: "roughly 40 percent of all individuals who submitted details to the fake military contractor" NS: dom.statistics.coverage BNE> CSV>BNE> <EVT:id=E1 <SBJ: e_individuals> <ACT:PAST:INDF:ACTV:IDCT:NIL:POS submit> <OBJ: e_contractor PRP=to SLK=recipient JBO> <OBJ: NIL PRP=NIL SLK=submits JBO>TVE><EVT:id=E2 <SBJ: e_sample> <ACT:PAST:INDF:ACTV:IDCT:NIL:POS cover> <OBJ: e_portion PRP=NIL SLK=covers JBO>TVE><EVT:id=E3 <SBJ: e_Belarus_security> <ACT:PAST:INDF:ACTV:IDCT:NIL:POS arrest> <OBJ: e_mercenaries PRP=NIL SLK=affects JBO> <OBJ: e_Minsk PRP=in SLK=location JBO>TVE><EVT:id=E4 <SBJ: e_sample> <ACT:PAST:INDF:ACTV:IDCT:NIL:POS encompass> <OBJ: e_mercenaries PRP=NIL SLK=includes JBO>TVE><CNJ E2 E1 "who" explanatory JNC><CNJ E4 E3 "arrested in" explanatory JNC>

MANDATORY:
Empty lines between FSP lines are strictly forbidden!

This is semantically and structurally equivalent to the Verbose version.

----------------------------------------------------------------------
8.4 Syntactic Safety Guarantees
----------------------------------------------------------------------

Both formats rely on FREGE‚Äôs explicit structural markers:

    ‚Ä¢ Unique open tags (e.g., <EVT, <OBJ, <ENB)
    ‚Ä¢ Unique asymmetric close tags (TVE>, TNP>, TL>, TE>, etc.)
    ‚Ä¢ Deterministic OBJ closure using JBO
    ‚Ä¢ Strict attribute grammar (PRP=‚Ä¶, SLK=‚Ä¶)

Because of these explicit markers, no structural ambiguity can arise.
Whitespace is never required to determine block boundaries.

Thus:
    ‚Ä¢ Removing indentation is safe.
    ‚Ä¢ Removing newlines is safe.
    ‚Ä¢ Collapsing spaces is safe (except where token separation is needed).

----------------------------------------------------------------------
8.6 Transformation Algorithms
----------------------------------------------------------------------

A. Decompression:
    - Scan input for '<'
    - On each '<TAG', start a new line
    - Track depth using open/close tags
    - Indent by depth
    - Output closing tags as standalone tokens

B. Compression:
    - Strip all indentation
    - Strip all newline characters
    - Normalize spaces to a minimum set
    - Ensure `<TAG...>` boundaries remain intact

Both algorithms are linear-time O(n).

----------------------------------------------------------------------
8.7 Encoding Mode Selection
----------------------------------------------------------------------

Applications may choose mode as follows:

    Verbose:
        - debugging FSP-2 profiles
        - human-facing UIs
        - education and audits

    Compact:
        - corpus-level FSP storage
        - transmitting FREGE profiles in workflows
        - large-scale semantic indexing/querying
        - model-to-model communication

Both modes are first-class citizens of FREGE-2.1.
Neither is ‚Äúintermediate‚Äù; both are canonical.

----------------------------------------------------------------------
8.8 Standardization Note
----------------------------------------------------------------------

Profiles MAY contain any mixture of Verbose and Compact blocks.


----------------------------------------------------------------------
8.9 Summary
----------------------------------------------------------------------

FREGE-2.1 supports dual-mode encoding:

    Verbose Mode  ‚Äî full readability
    Compact Mode  ‚Äî full density

The transformation is fully reversible and deterministic due to explicit,
unambiguous start/end tags.

This design maintains reversibility, syntactic safety, and maximal
efficiency without sacrificing the expressiveness of the FREGE-2.1 graph.
